{"value":{"mode":"pac_script","pacScript":{"data":"const compiledRules = {\n\t/** User defined whitelist rules. P2 */\n\tWhitelistRules: [],\n\t/** User defined rules. P1 */\n\tRules: [{search:unescape('ytimg.com'),regex:null,compiledRuleType:5},{search:unescape('youtube.com'),regex:null,compiledRuleType:5},{search:unescape('googlevideo.com'),regex:null,compiledRuleType:5}],\n\t/** Subscription whitelist rules. P3  */\n\tWhitelistSubscriptionRules: [],\n\t/** Subscription rules. P4 */\n\tSubscriptionRules: []\n};\nconst SmartProfileType = {\n\tDirect: 0,\n\tSystemProxy: 1,\n\tSmartRules: 2,\n\tAlwaysEnabledBypassRules: 3,\n\tIgnoreFailureRules: 4,\n}\nconst CompiledProxyRuleType = {\n\tRegexHost: 0,\n\tRegexUrl: 1,\n\tExact: 2,\n\tSearchUrl: 3,\n\tSearchDomain: 4,\n\tSearchDomainSubdomain: 5,\n\tSearchDomainAndPath: 6,\n\tSearchDomainSubdomainAndPath: 7\n}\nconst activeProfileType = +'2';\nconst currentProxyServer = \"SOCKS5 51.68.160.105:30863\";\nconst resultDirect = \"DIRECT\";\nconst resultSystem = \"SYSTEM\";\nconst verboseDiagnostics = false; // set to true for verbose logs using chrome flag. https://support.google.com/chrome/a/answer/6271171?hl=en#zippy=%2Cview-network-data%2Cget-network-logs\n// -------------------------\n// required PAC function that will be called to determine\n// if a proxy should be used.\nfunction FindProxyForURL(url, host, noDiagnostics) {\n\tif (verboseDiagnostics && !noDiagnostics) {\n\t\tlet finalResult = FindProxyForURL(url, host, true);\n\t\talert('SmartProxy-FindProxyForURL-Result=' + finalResult + '; host=' + host + '; url=' + url + '; activeProfile=' + activeProfileType);\n\t\treturn finalResult;\n\t}\n\n\tif (activeProfileType == SmartProfileType.SystemProxy)\n\t\treturn resultSystem;\n\n\tif (activeProfileType == SmartProfileType.Direct)\n\t\treturn resultDirect;\n\n\thost = host?.toLowerCase();\n\n\t// applying ProxyPerOrigin\n\t// is not applicable for Chromium\n\n\t// correcting 'host' because it doesn't include port number\n\tconst hostAndPort = extractHostFromUrl(url)?.toLowerCase() || host;\n\n\tif (activeProfileType == SmartProfileType.AlwaysEnabledBypassRules) {\n\n\t\t// user skip the bypass rules/ don't apply proxy\n\t\tlet userMatchedRule = findMatchedUrlInRules(url, host, hostAndPort, compiledRules.Rules);\n\t\tif (userMatchedRule) {\n\t\t\treturn makeResultForAlwaysEnabledForced(userMatchedRule)\n\t\t}\n\n\t\t// user bypass rules/ apply proxy by force\n\t\tlet userWhitelistMatchedRule = findMatchedUrlInRules(url, host, hostAndPort, compiledRules.WhitelistRules)\n\t\tif (userWhitelistMatchedRule) {\n\t\t\treturn resultDirect;\n\t\t}\n\n\t\t// subscription skip bypass rules/ don't apply proxy\n\t\tlet subMatchedRule = findMatchedUrlInRules(url, host, hostAndPort, compiledRules.SubscriptionRules);\n\t\tif (subMatchedRule) {\n\t\t\treturn makeResultForAlwaysEnabledForced(userMatchedRule)\n\t\t}\n\n\t\t// subscription bypass rules/ apply proxy by force\n\t\tlet subWhitelistMatchedRule = findMatchedUrlInRules(url, host, hostAndPort, compiledRules.WhitelistSubscriptionRules)\n\t\tif (subWhitelistMatchedRule) {\n\t\t\treturn resultDirect;\n\t\t}\n\n\t\t//** Always Enabled is forced by a rule, so other rules can't skip it */\n\t\tfunction makeResultForAlwaysEnabledForced(matchedRule) {\n\n\t\t\tif (matchedRule.proxy)\n\t\t\t\t// this rule has its own proxy setup\n\t\t\t\treturn matchedRule.proxy;\n\t\t\treturn currentProxyServer;\n\t\t}\n\n\t\t// no rule is matched, going with proxy\n\t\treturn currentProxyServer;\n\t}\n\n\tif (activeProfileType == SmartProfileType.SmartRules) {\n\n\t\t// user whitelist rules/ don't apply proxy\n\t\tlet userWhitelistMatchedRule = findMatchedUrlInRules(url, host, hostAndPort, compiledRules.WhitelistRules)\n\t\tif (userWhitelistMatchedRule) {\n\t\t\treturn makeResultForWhitelistRule(userWhitelistMatchedRule);\n\t\t}\n\n\t\t// user rules/ apply proxy\n\t\tlet userMatchedRule = findMatchedUrlInRules(url, host, hostAndPort, compiledRules.Rules);\n\t\tif (userMatchedRule) {\n\t\t\treturn makeResultForMatchedRule(userMatchedRule);\n\t\t}\n\n\t\t// subscription whitelist rules/ don't apply proxy\n\t\tlet subWhitelistMatchedRule = findMatchedUrlInRules(url, host, hostAndPort, compiledRules.WhitelistSubscriptionRules)\n\t\tif (subWhitelistMatchedRule) {\n\t\t\treturn makeResultForWhitelistRule(subWhitelistMatchedRule);\n\t\t}\n\n\t\t// subscription rules/ apply proxy\n\t\tlet subMatchedRule = findMatchedUrlInRules(url, host, hostAndPort, compiledRules.SubscriptionRules);\n\t\tif (subMatchedRule) {\n\t\t\treturn makeResultForMatchedRule(subMatchedRule);\n\t\t}\n\n\t\t/**\n\t\t * Generate result for matched whitelist rule\n\t\t */\n\t\tconst makeResultForWhitelistRule = () => {\n\t\t\treturn resultDirect;\n\t\t}\n\n\t\t/**\n\t\t * Generate result for matched proxy rule\n\t\t */\n\t\tfunction makeResultForMatchedRule(matchedRule) {\n\t\t\tif (matchedRule.proxy)\n\t\t\t\t// this rule has its own proxy setup\n\t\t\t\treturn matchedRule.proxy;\n\t\t\treturn currentProxyServer;\n\t\t}\n\t}\n\n\tif (activeProfileType == SmartProfileType.IgnoreFailureRules) {\n\t\t// NOTE: this is not a proxy profile, it is used elsewhere\n\t\t// No logic is needed here\n\t}\n\n\t// let the browser decide\n\treturn \"\";\n}\n\nfunction findMatchedUrlInRules(searchUrl, host, hostAndPort, rules) {\n\tif (searchUrl == null || rules == null || rules.length == 0)\n\t\treturn null;\n\n\tlet schemaLessUrlLowerCase = null;\n\tlet lowerCaseUrl = searchUrl.toLowerCase();\n\n\ttry {\n\t\tfor (let rule of rules) {\n\n\t\t\tswitch (rule.compiledRuleType) {\n\t\t\t\tcase CompiledProxyRuleType.SearchDomainSubdomain:\n\n\t\t\t\t\tif (host == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// domain\n\t\t\t\t\tif (host == rule.search)\n\t\t\t\t\t\treturn rule;\n\n\t\t\t\t\t// subdomains\n\t\t\t\t\tif (host.endsWith('.' + rule.search))\n\t\t\t\t\t\treturn rule;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CompiledProxyRuleType.Exact:\n\n\t\t\t\t\tif (lowerCaseUrl == rule.search)\n\t\t\t\t\t\treturn rule;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CompiledProxyRuleType.RegexHost:\n\t\t\t\t\tif (host == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rule.regex.test(host))\n\t\t\t\t\t\treturn rule;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CompiledProxyRuleType.RegexUrl:\n\t\t\t\t\t// Using original url with case sensitivity\n\t\t\t\t\tif (rule.regex.test(searchUrl))\n\t\t\t\t\t\treturn rule;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CompiledProxyRuleType.SearchUrl:\n\n\t\t\t\t\tif (lowerCaseUrl.startsWith(rule.search))\n\t\t\t\t\t\treturn rule;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CompiledProxyRuleType.SearchDomain:\n\n\t\t\t\t\tif (host == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (rule.search == host)\n\t\t\t\t\t\treturn rule;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CompiledProxyRuleType.SearchDomainAndPath:\n\n\t\t\t\t\tif (schemaLessUrlLowerCase == null) {\n\t\t\t\t\t\tschemaLessUrlLowerCase = removeSchemaFromUrl(lowerCaseUrl);\n\t\t\t\t\t\tif (schemaLessUrlLowerCase == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (schemaLessUrlLowerCase.startsWith(rule.search))\n\t\t\t\t\t\treturn rule;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CompiledProxyRuleType.SearchDomainSubdomainAndPath:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (schemaLessUrlLowerCase == null) {\n\t\t\t\t\t\t\tschemaLessUrlLowerCase = removeSchemaFromUrl(lowerCaseUrl);\n\t\t\t\t\t\t\tif (schemaLessUrlLowerCase == null) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (schemaLessUrlLowerCase.startsWith(rule.search))\n\t\t\t\t\t\t\treturn rule;\n\n\t\t\t\t\t\tlet ruleSearchHost = extractHostFromInvalidUrl(rule.search);\n\t\t\t\t\t\tif (ruleSearchHost != null) {\n\n\t\t\t\t\t\t\tif (host == null) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// should be the same\n\t\t\t\t\t\t\tif (ruleSearchHost != host && !host.endsWith('.' + ruleSearchHost))\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t// after this state, we are sure that the url is for the same domain, now just checking the path\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// subdomains\n\t\t\t\t\t\tif (schemaLessUrlLowerCase.includes('.' + rule.search))\n\t\t\t\t\t\t\treturn rule;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// reaching this point nothing is matched\n\t\t// if host has custom port number we need to check again\n\t\tif (host != hostAndPort) {\n\t\t\thost = hostAndPort;\n\t\t\t\n\t\t\tfor (let rule of rules) {\n\n\t\t\t\t// NOTE: Only rules that work on hostName should be checked, others can be ignored\n\t\t\t\tswitch (rule.compiledRuleType) {\n\n\t\t\t\t\tcase CompiledProxyRuleType.RegexHost:\n\t\t\t\t\t\tif (host == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (rule.regex.test(host))\n\t\t\t\t\t\t\treturn rule;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CompiledProxyRuleType.SearchDomain:\n\n\t\t\t\t\t\tif (host == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rule.search == host)\n\t\t\t\t\t\t\treturn rule;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CompiledProxyRuleType.SearchDomainSubdomain:\n\n\t\t\t\t\t\tif (host == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// domain\n\t\t\t\t\t\tif (host == rule.search)\n\t\t\t\t\t\t\treturn rule;\n\n\t\t\t\t\t\t// subdomains\n\t\t\t\t\t\tif (host.endsWith('.' + rule.search))\n\t\t\t\t\t\t\treturn rule;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CompiledProxyRuleType.SearchDomainSubdomainAndPath:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (schemaLessUrlLowerCase == null) {\n\t\t\t\t\t\t\t\tschemaLessUrlLowerCase = removeSchemaFromUrl(lowerCaseUrl);\n\t\t\t\t\t\t\t\tif (schemaLessUrlLowerCase == null) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (schemaLessUrlLowerCase.startsWith(rule.search))\n\t\t\t\t\t\t\t\treturn rule;\n\n\t\t\t\t\t\t\tlet ruleSearchHost = extractHostFromInvalidUrl(rule.search);\n\t\t\t\t\t\t\tif (ruleSearchHost != null) {\n\n\t\t\t\t\t\t\t\tif (host == null) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// should be the same\n\t\t\t\t\t\t\t\tif (ruleSearchHost != host && !host.endsWith('.' + ruleSearchHost))\n\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t\t// after this state, we are sure that the url is for the same domain, now just checking the path\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// subdomains\n\t\t\t\t\t\t\tif (schemaLessUrlLowerCase.includes('.' + rule.search))\n\t\t\t\t\t\t\t\treturn rule;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tcase CompiledProxyRuleType.Exact:\n\t\t\t\t\tcase CompiledProxyRuleType.RegexUrl:\n\t\t\t\t\tcase CompiledProxyRuleType.SearchUrl:\n\t\t\t\t\tcase CompiledProxyRuleType.SearchDomainAndPath:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} catch (e) {\n\t\tconsole.warn('SmartProxy> findMatchForUrl failed for ' + lowerCaseUrl, e);\n\t}\n\treturn null;\n}\n\nfunction removeSchemaFromUrl(url) {\n\tif (url == null)\n\t\treturn url;\n\tconst schemaSep = '://';\n\tlet index = url.indexOf(schemaSep);\n\tif (index > -1)\n\t\treturn url.substring(index + schemaSep.length, url.length);\n\telse\n\t\treturn url;\n}\nfunction extractHostFromInvalidUrl(url) {\n\ttry {\n\t\tif (!url.includes(\":/\"))\n\t\t\turl = 'http://' + url;\n\n\t\treturn extractHostFromUrl(url);\n\t}\n\tcatch (e) { return null; }\n}\nfunction extractHostFromUrl(url) {\n\t// Unescaped RegEx (/^(?:w)*://([^/?#]+)(?:[/?#]|$)/i);\n\tconst extractPattern = (/^(?:\\w)*\\:\\/\\/([^\\/?#]+)(?:[\\/?#]|$)/i);\n\n\tconst match = extractPattern.exec(url);\n\tif (!match) {\n\t\treturn null;\n\t}\n\tconst [, host] = match;\n\treturn host;\n}"}},"scope":"regular"}
